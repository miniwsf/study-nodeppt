<!doctype html><html><head><meta charset=UTF-8><title>QUIC - By wsf</title><link rel=stylesheet href=//cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=//cdn.staticfile.org/prism/1.15.0/themes/prism.min.css><link rel=stylesheet href=//cdn.staticfile.org/KaTeX/0.10.0-rc.1/katex.min.css><link href=./css/chunk-vendors.4e4765ff.css rel=stylesheet></head><body><div><article id=webslides><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><h2>QUIC</h2><p class="animated fadeInDown delay-800">(Quick UDP Internet Connections)</p></div></section><section slide class="slide aligncenter"><div class=wrap wrap=true><h3>QUIC是什么？</h3><div class="vertical-align grid"><div class="column text-description"><p>快速UDP网络连接（英语：Quick UDP Internet Connections），是一种实验性的网络传输协议。Google希望使用这个协议来取代HTTPS/HTTP协议，使网页传输速度加快。</p></div><div class=column><p>QUIC是由Google开发，旨在提供基于TLS/DTLS的网络安全保护，减少数据传输及创建连线时的延迟时间，双向控制带宽，以避免网络拥塞。</p></div></div></div></section><section slide class=slide><div class=wrap wrap=true><img src=https://miniwsf.github.io/study-nodeppt/quic/image/WechatIMG1.png class="size-40 alignleft"><div class="content-right text-label size-20"><h3>Why QUIC？</h3><ul class="specs bg-trans-dark flexblock"><li><div><h3>网络延迟</h3><p><code>RTT（往返时间）：是网络请求从起点到目的地并再次回到起点所花费的持续时间（以毫秒为单位）——衡量网络延迟的重要指标</code></p><p>网络延迟包含：处理延迟，排队延迟，传输延迟，传播延迟</p></div></li></ul></div></div></section><section slide class=slide><div class=wrap wrap=true><div class="vertical-align grid"><div class=column><img src=https://miniwsf.github.io/study-nodeppt/quic/image/chrome_waterfall.png class=alignleft></div><div class=column><table><thead><tr><th style=text-align:left>延迟时间（单位ms）</th><th style=text-align:center>用户反应</th></tr></thead><tbody><tr><td style=text-align:left>0 - 16</td><td style=text-align:center>用户可以感知每秒渲染 60 帧的平滑动画转场。也就是每帧 16 毫秒，留给应用大约 10 毫秒的时间来生成一帧。</td></tr><tr><td style=text-align:left>0 - 100</td><td style=text-align:center>在此时间窗口内响应用户操作，他们会觉得可以立即获得结果。时间再长，操作与反应之间的连接就会中断。</td></tr><tr><td style=text-align:left>100 - 300</td><td style=text-align:center>用户会遇到轻微可觉察的延迟。</td></tr><tr><td style=text-align:left>300 - 1000</td><td style=text-align:center>在此窗口内，延迟感觉像是任务自然和持续发展的一部分。对于网络上的大多数用户，加载页面或更改视图代表着一个任务。</td></tr><tr><td style=text-align:left>1000+</td><td style=text-align:center>超过 1 秒，用户的注意力将离开他们正在执行的任务。</td></tr><tr><td style=text-align:left>10,000+</td><td style=text-align:center>用户感到失望，可能会放弃任务；之后他们或许不会再回来。</td></tr></tbody></table></div></div></div></section><section slide class=slide><div class=wrap wrap=true><ul class="clients flexblock"><li><a><figure>TCP<figcaption><p>TCP快启动。</p><p>允许在SYN和SYN-ACK中携带数据，数据包和接收端在初始阶段消耗的数据包。连接握手，最多可节省一个完整的往返时间（RTT）</p><p>缺点：</p><ol><li>兼容差（TCP是操作系统内核实现）</li><li>隐私问题（和TCP快启动的实现有关了）</li></ol><p>如上原因，导致这个很少使用</p></figcaption></figure></a></li><li><a><figure>TSL<figcaption><p>TSL/1.3</p><p>将2RTT减少至1RTT</p></figcaption></figure></a></li><li><a><figure>HTTP<figcaption><p>http/1.1 connetion::keep-alive</p><p>http/2 多路复用</p><p>缺点：</p><ol><li>队头阻塞问题</li></ol></figcaption></figure></a></li></ul></div></section><section slide class=slide><div class=wrap wrap=true><h3>QUIC实现0-RTT</h3><div class="vertical-align grid"><div class=column><ul><li>基于UDP（面向无连接的），没有三次握手过程</li><li>首次进入：将TCP(1RTT)+TSL(2RTT)减少为1RTT（后续进入实现0-RTT）</li></ul></div><div class=column><img src=https://lh3.googleusercontent.com/o62Ohn1Ppxna6zz0NtavqRyetjryOj-81Sz4bRt3U8lURVblk5RKOaCcf57i6BkmprremePJpq_sQcxfJiuA4wJBmRp3pR4BS1P-yiT6UNUPvnBeP_rLz9bvHxFE15kuNBM2hpE></div></div></div></section><section slide class=slide><div class=wrap wrap=true><div class="vertical-align grid"><div class=column><p>TCP+TLS:</p><img src=https://www.yinchengli.com/wp-content/uploads/2018/06/8.png></div><div class=column><p>QUIC:</p><img src=https://www.yinchengli.com/wp-content/uploads/2018/06/9.png></div></div><p>（chrome数据：QUIC在糟糕的网络条件下胜过TCP，将Google搜索页面的加载时间缩短了整整一秒钟，这是最慢的1％的连接。对于YouTube等视频服务而言，这些优势更加明显。通过QUIC观看视频时，用户报告的重新缓冲减少了30％）</p></div></section><section slide class=slide><div class=wrap wrap=true><img src=https://miniwsf.github.io/study-nodeppt/quic/image/WechatIMG1.png class="size-40 alignleft"><div class=content-right><h3>Why QUIC？</h3><ul class="specs flexblock"><li><div><h3>网络延迟</h3></div></li><li><div><h3>队头阻塞</h3><p>队头阻塞——一个TCP分节丢失，导致其后续分节不按序到达接收端的时候。</p><p><code class="animated fadeInUp delay-800">HTTP/2实现多路复用：多个HTTP请求共用一个TCP连接，以减少TCP连接数，达到复用高速信道的作用。但是TCP连接中的单个丢失数据包使该连接上的所有多路复用停顿下来</code></p></div></li></ul></div></div></section><section slide class=slide><div class=wrap wrap=true><div class=content-center><h2>多路复用解决队头阻塞</h2><p>QUIC使用UDP协议作为其基础，不包括丢失恢复。相反，每个QUIC流是单独控制的，并且在QUIC级别而不是UDP级别重传丢失的数据。这意味着如果在一个流中发生错误，协议栈仍然可以独立地继续为其他流提供服务</p></div></div></section><section slide class=slide><div class=wrap wrap=true><img src=https://miniwsf.github.io/study-nodeppt/quic/image/WechatIMG1.png class="size-40 alignleft"><div class=content-right><h3>Why QUIC？</h3><ul class="specs flexblock"><li><div><h3>网络延迟</h3></div></li><li><div><h3>队头阻塞</h3></div></li><li><div><p class="text-subtitle animated fadeInUp delay-800">其他</p><ul><li class="animated fadeInUp delay-800">网络切换：当移动设备的用户从WiFi热点切换到移动网络时发生的情况。 当这发生在TCP上时，一个冗长的过程开始了：每个现有连接一个接一个地超时，然后根据需要重新创建</li></ul></div></li></ul></div></div></section><section slide class="slide aligncenter"><div class=wrap wrap=true><div class=text-cols><p>已经应用的公司：<br><code>Google</code> <code>youtube</code> <code>腾讯</code> <code>快手</code></p><p>感兴趣的话，可以细看下面的资料<br><a href=https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9FUDP%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5 target=_blank>快速UDP网络连接</a><br><a href=https://tools.ietf.org/html/draft-ietf-quic-transport-20 target=_blank>Draft-ietf-quic-transport-20</a><br><a href=https://blog.chromium.org/2015/04/a-quic-update-on-googles-experimental.html target=_blank>关于Google实验性运输的QUIC更新</a></p></div></div></section><section slide class="slide aligncenter"><div class=wrap wrap=true><p>感激～<br>over</p></div></section></article></div><script>window.pluginsOptions = {}



document.addEventListener('DOMContentLoaded', () => {
    let isPrintMode = false;
    if(~location.search.indexOf('print-pdf')){
        isPrintMode = true;
        WebSlides.registerPlugin('scroll', function(){});
    }
    const ws = new WebSlides({
        loop: false
    })
    window.wsInstance = ws;
    if(isPrintMode){
        ws.slides.forEach(s=>s.show())
    }
}, false)</script><script src=./js/chunk-vendors.js></script><script src=./js/quic.js></script></body></html>